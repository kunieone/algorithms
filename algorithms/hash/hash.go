/*
当我们在编程过程中，往往需要对线性表进行查找操作。
在顺序表中查找时，需要从表头开始，依次遍历比较a[i]与key的值是否相等，直到相等才返回索引i；
在有序表中查找时，我们经常使用的是二分查找，通过比较key与a[i]的大小来折半查找，直到相等时才返回索引i。最终通过索引找到我们要找的元素。
但是，这两种方法的效率都依赖于查找中比较的次数。我们有一种想法，能不能不经过比较，而是直接通过关键字key一次得到所要的结果呢？这时，就有了散列表查找（哈希表）。 */
package hash

/*
要说哈希表，我们必须先了解一种新的存储方式—散列技术。
　　　 散列技术是指在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每一个关键字都对应一个存储位置。即：存储位置=f（关键字）。这样，在查找的过程中，只需要通过这个对应关系f 找到给定值key的映射f（key）。只要集合中存在关键字和key相等的记录，则必在存储位置f（key）处。我们把这种对应关系f 称为散列函数或哈希函数。
　　　 按照这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为哈希表。所得的存储地址称为哈希地址或散列地址。
*/

func JSHash(str string) uint64 {

	var hash uint64 = 131511
	for i := 0; i < len(str); i++ {
		hash ^= ((hash << 5) + uint64(str[i]) + (hash >> 2))
	}
	return hash
}

// type NumSlice[T int | float64] []T

// type T =  [string | int | int64 | float32 | float64]
